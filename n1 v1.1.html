<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Привет, Мастер</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #05080f;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(0,255,200,0.13) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,200,0.13) 1px, transparent 1px);
            background-size: 64px 64px;
            z-index: 0;
            pointer-events: none;
        }

        canvas {
            position: fixed;
            inset: 0;
            pointer-events: none;
            will-change: transform; /* promote to GPU layer */
        }
        #cv-back  { z-index: 1; }
        #cv-front { z-index: 15; }

        /* Card */
        .card {
            position: relative;
            z-index: 10;
            text-align: center;
            padding: 60px 88px 52px;
            background: rgba(3, 5, 14, 0.90);
            border: 1px solid rgba(0, 255, 200, 0.65);
            border-radius: 2px;
            backdrop-filter: blur(20px);
            box-shadow:
                0 0 50px rgba(0, 255, 200, 0.20),
                0 0 110px rgba(130, 0, 255, 0.18),
                inset 0 0 70px rgba(0, 0, 0, 0.65);
            animation: cardFloat 11s ease-in-out infinite;
        }
        @keyframes cardFloat {
            0%, 100% { transform: translateY(0px); }
            50%       { transform: translateY(-9px); }
        }

        /* Corners */
        .c { position: absolute; width: 16px; height: 16px; border-color: rgba(0,255,200,1.0); border-style: solid; filter: drop-shadow(0 0 4px rgba(0,255,200,0.8)); }
        .tl { top:-1px; left:-1px;  border-width:2px 0 0 2px; }
        .tr { top:-1px; right:-1px; border-width:2px 2px 0 0; }
        .bl { bottom:-1px; left:-1px;  border-width:0 0 2px 2px; }
        .br { bottom:-1px; right:-1px; border-width:0 2px 2px 0; }

        .tag {
            font-size: 10px;
            letter-spacing: 5px;
            color: rgba(0,255,200,0.90);
            text-transform: uppercase;
            margin-bottom: 30px;
        }

        /* Main greeting */
        .greeting {
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: clamp(2rem, 5vw, 3.6rem);
            letter-spacing: 0.42em;
            line-height: 1;
            display: inline-block;
            background: linear-gradient(120deg, #00ffc8 0%, #7c6bff 35%, #f472b6 65%, #00ffc8 100%);
            background-size: 250% 250%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: textFloat 8s ease-in-out infinite, gradShift 9s ease infinite;
            filter: drop-shadow(0 0 28px rgba(0,255,200,0.55));
        }
        @keyframes textFloat {
            0%   { transform: scaleY(0.76) translateY(0px); }
            30%  { transform: scaleY(0.76) translateY(-11px); }
            60%  { transform: scaleY(0.76) translateY(-4px); }
            100% { transform: scaleY(0.76) translateY(0px); }
        }
        @keyframes gradShift {
            0%   { background-position: 0%   50%; filter: drop-shadow(0 0 28px rgba(0,255,200,0.55)); }
            50%  { background-position: 100% 50%; filter: drop-shadow(0 0 40px rgba(167,139,250,0.75)); }
            100% { background-position: 0%   50%; filter: drop-shadow(0 0 28px rgba(0,255,200,0.55)); }
        }

        .subtitle {
            font-size: 0.82rem;
            letter-spacing: 4px;
            color: rgba(190,170,255,0.90);
            text-transform: uppercase;
            margin-top: 22px;
            margin-bottom: 36px;
        }

        .divider {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 30px;
        }
        .dl { flex:1; height:1px; background:linear-gradient(90deg,transparent,rgba(0,255,200,0.85),transparent); }
        .dd {
            width:4px; height:4px; border-radius:50%;
            background:#00ffc8; box-shadow:0 0 8px #00ffc8;
            animation: blink 2.8s ease-in-out infinite;
        }
        @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.1} }

        .status {
            display: flex;
            gap: 22px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .si {
            display:flex; align-items:center; gap:7px;
            font-size:0.7rem; letter-spacing:2px;
            color:rgba(190,175,255,0.95); text-transform:uppercase;
        }
        .sd { width:5px; height:5px; border-radius:50%; animation:blink 2s ease-in-out infinite; }
        .cyan   { background:#00ffc8; box-shadow:0 0 6px #00ffc8; }
        .purple { background:#a78bfa; box-shadow:0 0 6px #a78bfa; animation-delay:.7s; }
        .pink   { background:#f472b6; box-shadow:0 0 6px #f472b6; animation-delay:1.3s; }

        .footer {
            position:fixed; bottom:20px; z-index:10;
            font-size:.62rem; letter-spacing:4px;
            color:rgba(0,255,200,0.55); text-transform:uppercase;
        }
    </style>
</head>
<body>

<canvas id="cv-back"></canvas>

<div class="card">
    <div class="c tl"></div><div class="c tr"></div>
    <div class="c bl"></div><div class="c br"></div>
    <div class="tag">// system online //</div>
    <h1 class="greeting">Привет, Мастер!</h1>
    <p class="subtitle">Добро пожаловать в систему</p>
    <div class="divider"><div class="dl"></div><div class="dd"></div><div class="dl"></div></div>
    <div class="status">
        <div class="si"><div class="sd cyan"></div><span>Связь активна</span></div>
        <div class="si"><div class="sd purple"></div><span>Защита включена</span></div>
        <div class="si"><div class="sd pink"></div><span>Всё спокойно</span></div>
    </div>
</div>

<canvas id="cv-front"></canvas>
<div class="footer">cyber · space · v2.0</div>
<div id="fps" style="
    position: fixed; top: 16px; right: 18px; z-index: 100;
    font-family: 'Orbitron', monospace; font-size: 11px;
    color: rgba(0,255,200,0.55); letter-spacing: 2px;
    pointer-events: none;
">-- FPS</div>

<script>
const cvB = document.getElementById('cv-back');
const cvF = document.getElementById('cv-front');
const ctxB = cvB.getContext('2d');
const ctxF = cvF.getContext('2d');

let W, H;
function resize() {
    W = cvB.width = cvF.width = window.innerWidth;
    H = cvB.height = cvF.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ── 3D config ──────────────────────────────────────────
const PERSP   = 820;
const Z_FAR   = 420;
const Z_NEAR  = 280;
const FRONT_Z = 60;

const COLS = [
    [255, 20,  40 ],   // насыщенный красный
    [20,  255, 80 ],   // насыщенный зелёный
];

// ── Sprite cache ────────────────────────────────────────
// Each color gets ONE pre-rendered offscreen canvas.
// Per-frame we use drawImage() instead of creating gradients — ~20x faster.
const SPRITE_R = 40; // body radius in sprite (px)
const SPRITE_SZ = SPRITE_R * 6; // canvas size: body + 2× glow padding each side

function makeSprite([r, g, b]) {
    const sc = document.createElement('canvas');
    sc.width = sc.height = SPRITE_SZ;
    const c = sc.getContext('2d');
    const cx = SPRITE_SZ / 2;

    // Outer glow
    const glow = c.createRadialGradient(cx, cx, 0, cx, cx, SPRITE_R * 2.8);
    glow.addColorStop(0,   `rgba(${r},${g},${b},0.30)`);
    glow.addColorStop(0.5, `rgba(${r},${g},${b},0.10)`);
    glow.addColorStop(1,   `rgba(${r},${g},${b},0)`);
    c.fillStyle = glow;
    c.beginPath();
    c.arc(cx, cx, SPRITE_R * 2.8, 0, Math.PI * 2);
    c.fill();

    // Sphere body with specular highlight
    const body = c.createRadialGradient(
        cx - SPRITE_R * 0.3, cx - SPRITE_R * 0.34, SPRITE_R * 0.04,
        cx, cx, SPRITE_R
    );
    body.addColorStop(0,    `rgba(255,255,255,0.75)`);
    body.addColorStop(0.22, `rgba(${r},${g},${b},1.0)`);
    body.addColorStop(0.65, `rgba(${r},${g},${b},0.55)`);
    body.addColorStop(1,    `rgba(${r},${g},${b},0.02)`);
    c.fillStyle = body;
    c.beginPath();
    c.arc(cx, cx, SPRITE_R, 0, Math.PI * 2);
    c.fill();

    // Bottom rim reflection
    const rimY = cx + SPRITE_R * 0.55;
    const rim = c.createRadialGradient(cx, rimY, 0, cx, rimY, SPRITE_R * 0.42);
    rim.addColorStop(0, 'rgba(255,255,255,0.22)');
    rim.addColorStop(1, 'rgba(255,255,255,0)');
    c.fillStyle = rim;
    c.beginPath();
    c.arc(cx, rimY, SPRITE_R * 0.42, 0, Math.PI * 2);
    c.fill();

    return sc;
}

const sprites = COLS.map(makeSprite);

// ── Bubble ──────────────────────────────────────────────
class Bubble {
    constructor(spread) { this.spawn(spread); }

    spawn(spread = false) {
        this.x  = (Math.random() - 0.5) * W * 1.5;
        this.y  = spread
            ? (Math.random() - 0.5) * H * 1.5
            : H * 0.55 + Math.random() * H * 0.4;

        this.z0     = Math.random() * (Z_FAR + Z_NEAR) - Z_FAR;
        this.z      = this.z0;
        this.vx     = (Math.random() - 0.5) * 0.22;
        this.vy     = -(Math.random() * 0.3 + 0.1);
        this.zAmp   = Math.random() * 130 + 60;
        this.zSpd   = Math.random() * 0.0005 + 0.0002;
        this.phi    = Math.random() * Math.PI * 2;
        this.wAmpX  = Math.random() * 0.35 + 0.08;
        this.wAmpY  = Math.random() * 0.22 + 0.05;
        this.wSpd   = Math.random() * 0.0006 + 0.0003;
        this.r      = Math.random() * 9 + 3;

        const ci    = Math.floor(Math.random() * COLS.length);
        this.sprite = sprites[ci];
        const [rv, gv, bv] = COLS[ci];
        this.dotColor = `rgb(${rv},${gv},${bv})`; // for LOD dots
    }

    update(t) {
        this.z  = this.z0 + Math.sin(t * this.zSpd + this.phi) * this.zAmp;
        this.x += this.vx + Math.sin(t * this.wSpd + this.phi) * this.wAmpX;
        this.y += this.vy + Math.cos(t * this.wSpd * 0.8 + this.phi) * this.wAmpY;
        if (this.y < -H * 0.65) this.spawn(false);
    }

    draw(ctx) {
        const scale = PERSP / (PERSP + Z_FAR - this.z);
        const sx = W / 2 + this.x * scale;
        const sy = H / 2 + this.y * scale;
        const sr = this.r * scale; // screen body radius

        if (sr < 0.4) return;

        // Frustum cull: sprite extends to sr*3 from center
        const ext = sr * 3;
        if (sx + ext < 0 || sx - ext > W || sy + ext < 0 || sy - ext > H) return;

        const alpha = Math.min(0.82, scale * 0.88);

        if (sr < 1.8) {
            // LOD: far/tiny bubble → single filled dot, no sprite overhead
            ctx.globalAlpha = alpha * 0.5;
            ctx.fillStyle   = this.dotColor;
            ctx.beginPath();
            ctx.arc(sx, sy, sr, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Sprite draw: body in sprite = SPRITE_R, on screen = sr
            // draw size = sr * 6  (since sprite is SPRITE_R * 6)
            const ds = sr * 6;
            ctx.globalAlpha = alpha;
            ctx.drawImage(this.sprite, sx - ds * 0.5, sy - ds * 0.5, ds, ds);
        }

        ctx.globalAlpha = 1;
    }
}

// ── Init ────────────────────────────────────────────────
const bubbles = Array.from({length: 62}, () => new Bubble(true));

// ── Render loop ─────────────────────────────────────────
// Use a stable sort: z changes slowly, so the array stays nearly sorted
// (Timsort handles nearly-sorted in O(n) — very cheap)
let rafId;
const fpsEl = document.getElementById('fps');
let fpsFrames = 0, fpsLast = 0;

function frame(t) {
    // FPS counter (update every second)
    fpsFrames++;
    if (t - fpsLast >= 1000) {
        fpsEl.textContent = fpsFrames + ' FPS';
        fpsEl.style.color = fpsFrames >= 50 ? 'rgba(0,255,120,0.75)' : 'rgba(255,210,0,0.85)';
        fpsFrames = 0;
        fpsLast   = t;
    }
    ctxB.clearRect(0, 0, W, H);
    ctxF.clearRect(0, 0, W, H);

    bubbles.sort((a, b) => a.z - b.z); // back → front

    for (const b of bubbles) {
        b.update(t);
        b.draw(b.z > FRONT_Z ? ctxF : ctxB);
    }

    rafId = requestAnimationFrame(frame);
}

// Pause when tab is hidden to save resources
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        cancelAnimationFrame(rafId);
    } else {
        rafId = requestAnimationFrame(frame);
    }
});

rafId = requestAnimationFrame(frame);
</script>
</body>
</html>
